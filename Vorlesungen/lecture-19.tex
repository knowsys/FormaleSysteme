\documentclass[aspectratio=1610,onlymath]{beamer}
% \documentclass[aspectratio=1610,onlymath,handout]{beamer}

\input{macros-lecture}
\input{../macros}

% \usetikzlibrary{shapes}
\usetikzlibrary{shapes.geometric}

\defineTitle{19}{Nichtdeterminismus und Turingmächtigkeit}{5. Januar 2026}

\begin{document}

\maketitle


\sectionSlide{Rückblick}

\begin{frame}\frametitle{Paris im August 1900}\label{frame_paris}

~\hfill
\includegraphics[height=6.5cm]{images/Paris-1900-Weltausstellung}
\hfill~

\end{frame}

\begin{frame}\frametitle{Der 2. Internationale Mathematikerkongress}\label{frame_hilbert}

\begin{minipage}{7cm}
\anybox{purple}{
"`Wer von uns würde nicht gern den Schleier lüften, unter dem die Zukunft verborgen liegt, um einen Blick zu werfen auf die bevorstehenden Fortschritte unsrer Wissenschaft und in die Geheimnisse ihrer Entwickelung während der künftigen Jahrhunderte!"'\\
\mbox{}\hfill-- David Hilbert, Paris, August 1900
}
\end{minipage}
\begin{minipage}{2.5cm}
~\hspace{8mm}
\includegraphics[width=2cm]{images/Hilbert}
\end{minipage}
\medskip\pause

Hilbert präsentiert eine Liste offener Fragen für die Mathematik des 20. Jahrhunderts:
\begin{itemize}
	\item 1. Problem: Kontinuumshypothese (und Auswahlaxiom)
	\item 2. Problem: Widerspruchsfreiheit der Arithmetik
	\item \ldots
\end{itemize}


\end{frame}

\begin{frame}\frametitle{Hilberts Programm}

Aber Hilberts wahres Ziel ist ein neues Verständnis der \ghost{Mathematik:}
\medskip

\anybox{purple}{
"`So unzugänglich diese Probleme uns erscheinen und so ratlos wir zur Zeit ihnen gegenüber stehen -- wir haben dennoch die sichere Ueberzeugung, daß ihre \alert{Lösung durch eine endliche Anzahl rein logischer Schlüsse} gelingen muß.

[\ldots]

Diese Ueberzeugung von der \alert{Lösbarkeit eines jeden mathematischen Problems} ist uns ein kräftiger Ansporn während der Arbeit; wir hören in uns den steten Zuruf: \alert{Da ist das Problem, suche die Lösung.} Du kannst sie durch reines Denken finden; denn in der Mathematik giebt es kein Ignorabimus$^*$!"'
\\
\mbox{}\hfill-- David Hilbert, Paris, August 1900
}

$^*)$ lat. "`wir werden es niemals wissen"'
% \bigskip
%

\end{frame}

\begin{frame}\frametitle{Der Rest ist Geschichte \ldots}

\begin{itemize}
\item 1910--1913: Whitehead und Russel formalisieren in ihrer \alert{Principia Mathematica} logische Grundlagen der Mathematik\pause
\item 1918--1922: Hilbert spezifiziert sein Programm zur widerspruchsfreien Formalisierung der Mathematik\pause
\item 1928: Hilbert beschreibt das \alert{Entscheidungsproblem} der Prädikatenlogik\pause
\item 1929: Gödel beweist seinen \alert{Vollständigkeitssatz}: "`es gibt ein Kalkül, das alle Wahrheiten der Prädikatenlogik endlich beweisen kann"'\pause
\item 1936: Turing definiert ein universelles Rechenmodell: die \alert{Turingmaschine}\pause
\item 1951: Tarski publiziert ein Verfahren, mit dem alle wahren logischen Aussagen über reelle Zahlen, $+$ und $*$ automatisch durch Computer entschieden werden können
\end{itemize}

\end{frame}

\begin{frame}\frametitle{Der Rest ist Geschichte \ldots}

\begin{itemize}
\item 1976: Computerbeweis des Vier-Farben-Problems (Appel \& \ghost{Haken)}\pause
\item 1992: IBM's Supercomputer WHILE-S beweist die Fermatsche Vermutung\pause
\item ab 1995: erste Programmierumgebungen mit automatischer Verifikation\pause
\item 2001: IBM beweist die Goldbachsche Vermutung\pause
\item 2005: Google beweist die Riemannsche Vermutung\pause
\item 2007: "`American Mathematical Society"' benennt sich um in "`Association of Mathematical Programmers"'\pause
\item 2010: Zusammenbruch des Banksystems infolge der Veröffentlichung des Computerbeweises zur Entschlüsselung von Public-Key-Kryptographie\pause
\item 2013: Einstellung des Studiengangs Mathematik an der TU Dresden (Übertragung der Mathematiklehrer-Ausbildung an die Fakultät Informatik)
\end{itemize}

\end{frame}

\begin{frame}\frametitle{}

\pause
\begin{center}
{\huge\redalert{So ist es nicht gewesen.$^*$}}
\vspace{1cm}

\visible<3->{{\huge\alert{Warum nicht?}}}
\visible<4->{\vspace{5mm}

\begin{minipage}{7.5cm}
\begin{enumerate}[(A)]
\visible<4-7>{\item Historischer Zufall -- es kam einfach anders}
\visible<5-7>{\item Die Hardware ist noch nicht so weit}
\visible<6-7>{\item Die Software ist noch nicht so weit}
\visible<7-8>{\item Die beschriebene Entwicklung ist in unserem Universum unmöglich}
\end{enumerate}
\end{minipage}}
\end{center}
\vspace{1cm}

$^*)$ alle Ereignisse ab 1992 sind nie passiert

\end{frame}

\begin{frame}\frametitle{Informatik als Naturwissenschaft}

\anybox{strongyellow}{\vspace{-5mm}\begin{center}
Informatik erforscht, was Computer sind\\ und welche Probleme man mit ihnen lösen kann.\end{center}}\bigskip\pause

Computer = ein System das rechnet (CMOS-Schaltkreise, die Turingmaschine, DNA-Moleküle, ein quantenmechanisches System, das Universum, Minecraft, \ldots)
\bigskip

Ziel: universelle Erkenntnisse -- nicht nur über die Computertechnologie, die wir gerade nutzen, sondern über die Welt, in der wir leben  {\tiny wie Physik}
\bigskip

Methode: Spezifikation von einfachen Regeln, aus denen komplexe Systeme entstehen {\tiny anders als Physik, die mit dem System anfängt und dessen "`Regeln"' sucht}

\end{frame}

\begin{frame}\frametitle{Kernfragen der theoretischen Informatik}

\begin{itemize}
\item Was heißt "`berechnen"'?
\item Welche Probleme kann man auf reellen Computern lösen?
\item Was wäre wenn wir mächtigere Computer hätten?
\item Was macht Rechenprobleme "`schwer"' oder "`einfach"'?
\item Sind alternative Rechenmodelle denkbar?
\item Welche (mathematischen/physikalischen/biologischen) Systeme können sonst noch rechnen?
\end{itemize}

Diese finden sich wieder in zahlreichen Teilgebieten (Berechenbarkeit, Automaten, Komplexität, Quantencomputing, logisches Schließen, künstliche Intelligenz, \ldots)

\end{frame}


\frame{\begin{center}\label{frame_turing_child}
\LARGE
Rückblick: Turingmaschinen\bigskip

\includegraphics[height=5cm]{images/Turing-5.jpg}\\
{\tiny Alan Turing (5 Jahre alt)}
\end{center}}

\begin{frame}\frametitle{Turingmaschinen -- informell}

\emph{Schematische Darstellung:}\medskip

\narrowcentering{%
\begin{tikzpicture}[
	scale=0.50,
	decoration=penciline, decorate
]
% \path[use as bounding box] (-3.2,0) rectangle (3.5,-5); % add "draw" to see it
% \draw[help lines] (0,0) grid (5,5);
\pgfmathsetseed{5712}
%
\node (inlabel) [rectangle,draw=none,inner sep=1pt] at (3,0.5) {\alert{Eingabe-/Speicherband}};
\draw[decorate,line width=0.3mm] (-1,0) -- (10.5,0);
\draw[decorate,line width=0.3mm] (-1,-1) -- (10.5,-1);
\foreach \x in {0,...,10} {
	\draw[decorate,line width=0.3mm] (\x-1,0) -- (\x-1,-0.9);
	\node (s\x) [circle,draw=none,inner sep=1pt] at (\x-0.5,-0.5) {\ifthenelse{\x<5}{\ifthenelse{\x<3}{\Sterm{a}}{\Sterm{b}}}{\ifthenelse{\x=5 \OR \x=7 \OR \x=8}{\Snterm{C}}{\ifthenelse{\x=9}{\Sterm{b}}{\Snterm{D}}}}};
}
\draw[decorate,line width=0.3mm] (10,0) -- (10,-0.9);
\node (dots) [circle,draw=none,inner sep=1pt] at (11.1,-0.5) {$\cdots$};

% \draw[decorate,line width=0.3mm] (5.5,0) -- (6,0) -- (6,-0.9) -- (5.5,-0.9) ;
% \draw[decorate,line width=0.3mm] (6,0) -- (6,-0.9);

\draw[fill=none,decorate,line width=0.3mm]
	(2,-3) -- (6,-3) -- (6,-7) -- (2,-7) -- cycle;
\node (falabel) [circle,draw=none,inner sep=1pt,align=left] at (4,-5) {Endliche\\Steuerung};
\draw[fill=none,decorate,line width=0.4mm,darkblue,->]
	(4,-3) -- (4,-2) -- (6.5,-2) -> (6.5,-1);
\node (headlabel) [rectangle,draw=none,inner sep=1pt,align=left] at (9.5,-2.0) {\footnotesize\alert{Lese-/Schreibkopf}\\[-0.6ex]\footnotesize\alert{(beweglich)}};

\node[rectangle,align=center,draw,line width=0.3mm,decorate, minimum width=8mm, minimum height=8mm] (state) at (8, -6) {$q$};
\draw[fill=none,decorate,line width=0.4mm,darkblue,->]
	(6,-6) -> (state.180);
\node (qlabel) [rectangle,draw=none,inner sep=1pt] at (11.5,-6) {\footnotesize\alert{Zustandsvariable}};

% \node[cloud, cloud puffs=15.7, cloud ignores aspect, minimum width=4cm, minimum height=1cm, align=center, draw,line width=0.3mm] (memory) at (11, -1) {\alert{zusätzlicher}\\\alert{Speicher}};
%
% \draw[fill=none,decorate,line width=0.3mm] (9,0) -- (14,0);
% \draw[fill=none,decorate,line width=0.3mm] (9,-1) -- (14,-1);
% \draw[fill=none,decorate,line width=0.3mm] (9,0) -- (9,-1);
% \foreach \y in {10,...,14} {
% 	\draw[fill=none,decorate,line width=0.3mm] (\y,0) -- (\y,-0.9);
% 	\node (k\y) [circle,draw=none,inner sep=1pt] at (\y-0.5,-0.5) {\ifthenelse{\y<12}{\Snterm{A}}{\Snterm{B}}};
% }
% \draw[fill=none,decorate,line width=0.4mm,darkblue,->]
% 	(6,-3.5) -- (7.5,-3.5) -- (7.5,-0.5) -> (9,-0.5);
% \node (stacklabel) [circle,draw=none,inner sep=1pt] at (11.5,-1.5) {\alert{Warteschlange}};
\end{tikzpicture}}
\bigskip\pause

\emph{Übergangsfunktion:}
\begin{itemize}
\item \alert{Eingabe:} aktueller Zustand, gelesenes Zeichen
\item \alert{Ausgabe:} neuer Zustand, geschriebenes Zeichen, Änderung Lese-/Schreibadresse (${}\hat{=}{}$ Bewegung Lese-/Schreibkopf)
\end{itemize}

\end{frame}

\begin{frame}\frametitle{Definition DTM}

\defbox{Eine \redalert{deterministische Turingmaschine} (DTM) ist ein Tupel
$\Smach{M}=\tuple{Q,\Sigma,\Gamma,\delta,q_0,F}$ mit
den folgenden Bestandteilen:
\begin{itemize}
\item $Q$: endliche Menge von \redalert{Zuständen}
\item $\Sigma$: \redalert{Eingabealphabet}
\item $\Gamma$: \redalert{Arbeitsalphabet} mit $\Gamma\supseteq\Sigma\cup\{\blank\}$
\item $\delta$: \redalert{Übergangsfunktion}, eine partielle Funktion\\[1ex]
\narrowcentering{$Q\times\Gamma \to Q\times\Gamma\times\{L,R,N\}$}
\item $q_0$: \redalert{Startzustand} $q_0\in Q$
\item $F$: Menge von akzeptierenden \redalert{Endzuständen} $F\subseteq Q$
\end{itemize}
}

\alert{Dabei bedeutet $\delta(q,a)=\tuple{p,b,D}$:}\\
\hspace{5mm}"`Liest die TM in Zustand $q$ unter dem Lese-/Schreibkopf ein $a$,\\
\hspace{5.8mm}dann wechselt sie zu Zustand $p$, überschreibt das $a$ mit $b$\\
\hspace{5.8mm}und verschiebt den Lese-/Schreibkopf gemäß $D\in\{L,R,N\}$\\
\hspace{5.8mm}(nach links, nach rechts, gar nicht)."'

\end{frame}

\begin{frame}\frametitle{Beispiel}

\emph{Wir können TMs in Diagrammen darstellen:}\medskip

Ein Pfeil $s_1\mapsto s_2,D$ von $q_1$ nach $q_2$ bedeutet\\
$\delta(q_1,s_1)=\tuple{q_2,s_2,D}$ (DTM) bzw. $\tuple{q_2,s_2,D}\in\delta(q_1,s_1)$ (NTM)
\bigskip

\emph{Beispiel:}\medskip

\begin{center}
\begin{tikzpicture}[baseline={(q1.base)}]
% \draw[help lines] (0,0) grid (7,2);
\node (q1) [circle,draw=black,thick] at (0,0) {$q_0$};
\node (q2) [circle,double,draw=black,thick] at (3,0) {$q_1$};
%
\path[->,line width=0.5mm](-1,0) edge (q1);
\path[->,line width=0.5mm](q1) edge node[below,align=left] {$\Sterm{0}\mapsto\Sterm{1},R$\\$\blank\mapsto\Sterm{1},R$} (q2);
\path[->,line width=0.5mm](q1) edge[loop above] node[above] {$\Sterm{1}\mapsto\Sterm{0},R$} (q1);
\end{tikzpicture}
\end{center}

Was tut diese Turingmaschine?

\end{frame}

\begin{frame}\frametitle{TM: Beispiel Abarbeitung}

TMs gehen schrittweise von einer Konfiguration in die nächste über:

\begin{center}
\begin{tikzpicture}[baseline={(q1.base)}]
% \draw[help lines] (0,0) grid (7,2);
\node (q1) [circle,draw=black,thick] at (0,0) {$q_0$};
\node (q2) [circle,double,draw=black,thick] at (3,0) {$q_1$};
%
\path[->,line width=0.5mm](-1,0) edge (q1);
\path[->,line width=0.5mm](q1) edge node[below,align=left] {$\Sterm{0}\mapsto\Sterm{1},R$\\$\blank\mapsto\Sterm{1},R$} (q2);
\path[->,line width=0.5mm](q1) edge[loop above] node[above] {$\Sterm{1}\mapsto\Sterm{0},R$} (q1);
\end{tikzpicture}
\end{center}

Eingabe: $\Sterm{1101}$\bigskip\pause

$q_0\Sterm{1101}\pause\vdash \Sterm{0}q_0\Sterm{101}\pause\vdash \Sterm{00}q_0\Sterm{01}\pause\vdash \Sterm{001}q_1\Sterm{1}$
\bigskip\pause

Ausgabe: $\Sterm{0011}$

\end{frame}


\sectionSlide{Nichtdeterministische Turingmaschinen}

\begin{frame}\frametitle{Nichtdeterministische TMs}

\defbox{%
\redalert{Die nichtdeterministische Turingmaschine} (NTM)
\begin{enumerate}[\ldots]
\item modelliert die Übergangsfunktion als totale Funktion:\\[1ex]
\narrowcentering{$Q\times\Gamma \to 2^{Q\times\Gamma\times\{L,R,N\}}$}\\
wobei $2^{Q\times\Gamma\times\{L,R,N\}}$ die Potenzmenge von $Q\times\Gamma\times\{L,R,N\}$ ist
\item kann weiterhin mit einem einzigen Anfangszustand arbeiten
\end{enumerate}}\medskip

\redalert{Läufe} werden wie bei DTMs definiert, aber jetzt kann es pro Eingabe viele Läufe geben
\medskip

Die Eingabe wird akzeptiert, wenn mindestens ein Lauf endlich ist und in einer akzeptierenden Konfiguration endet

\end{frame}


\begin{frame}\frametitle{Definition NTM}

\defbox{Eine \redalert{nichtdeterministische Turingmaschine} (NTM) ist ein Tupel
$\Smach{M}=\tuple{Q,\Sigma,\Gamma,\delta,q_0,F}$ mit
den folgenden Bestandteilen:
\begin{itemize}
\item $Q$: endliche Menge von \redalert{Zuständen}
\item $\Sigma$: \redalert{Eingabealphabet}
\item $\Gamma$: \redalert{Arbeitsalphabet} mit $\Gamma\supseteq\Sigma\cup\{\blank\}$
\item $\delta$: \redalert{Übergangsfunktion}, eine totale Funktion\\[1ex]
\narrowcentering{$Q\times\Gamma \to 2^{Q\times\Gamma\times\{L,R,N\}}$}\\
wobei $2^{Q\times\Gamma\times\{L,R,N\}}$ die Potenzmenge von $Q\times\Gamma\times\{L,R,N\}$ ist
\item $q_0$: \redalert{Startzustand} $q_0\in Q$
\item $F$: Menge von akzeptierenden \redalert{Endzuständen} $F\subseteq Q$
\end{itemize}
}

\alert{Dabei bedeutet $\tuple{p,b,D}\in\delta(q,a)$:}\\
\hspace{5mm}"`Liest die TM in Zustand $q$ unter dem Lese-/Schreibkopf ein $a$,\\
\hspace{5.8mm}dann \alert{kann} sie zu Zustand $p$ wechseln, $a$ mit $b$ überschreiben\\
\hspace{5.8mm}und den Lese-/Schreibkopf gemäß $D\in\{L,R,N\}$ verschieben."'

\end{frame}


\begin{frame}\frametitle{Wiederholung Grundbegriffe}

\redalert{Konfiguration:} der "`Gesamtzustand"' einer TM, bestehend aus Zustand, Bandinhalt und Position des Lese-/Schreibkopfs;\\[1ex]
geschrieben als Wort (Bandinhalt), in dem der Zustand vor der Position des Kopfes eingefügt ist
\bigskip

\redalert{Übergangsrelation:} Beziehung zwischen zwei Konfigurationen wenn die TM von der ersten in die zweite übergehen kann (deterministisch oder nichtdeterministisch); geschrieben als $\vdash$
\bigskip

\redalert{Lauf:} mögliche Abfolge von Konfigurationen einer TM, beginnend mit der Startkonfiguration; kann endlich oder unendlich sein
\bigskip

\redalert{Halten:} Ende der Abarbeitung, wenn die TM in einer Konfiguration keinen Übergang mehr zur Verfügung hat

\end{frame}

\begin{frame}\frametitle{Was ist das Ergebnis einer TM-Berechnung?}

Es gibt zwei wesentliche Arten DTMs zu benutzen:

\begin{enumerate}[(1)]
\item \alert{Transducer:} Ausgabe der TM ist der Inhalt des Bandes, wenn sie hält, oder undefiniert, wenn sie nicht hält (partielle Funktion); Endzustände spielen keine Rolle und können weggelassen werden
\item \alert{Entscheider:} Ausgabe der TM hat nur zwei Werte: die TM "`akzeptiert"', wenn sie in einem Endzustand hält und sie "`verwirft"' wenn sie in einem Nicht-Endzustand oder gar nicht hält;
Bandinhalt beim Halten spielt keine Rolle und kann ignoriert werden
\end{enumerate}

Wir werden NTMs nur als Entscheider verwenden: in diesem Fall reicht es, wenn mindestens ein möglicher Lauf akzeptiert.

\end{frame}


\begin{frame}[t]\frametitle{Nichtdeterminismus $\neq$ mehr Ausdrucksstärke\phantom{g}}

\theobox{\emph{Satz:} Jede NTM ist äquivalent zu einer DTM.}\pause

\emph{Beweis:} Allgemeine Idee:
\begin{itemize}
\item Wir simulieren systematisch einen Lauf nach dem anderen
\item Die simulierende TM akzeptiert die Eingabe, wenn ein akzeptierender Lauf gefunden wird
\item Andernfalls hält sie nicht an
\end{itemize}\pause

\alert{Wie kann man systematisch alle möglichen Läufe testen?}
\begin{itemize}
\item Tiefensuche: berechne zunächst einen Lauf; falls dieser fehlschlägt, dann gehe zum letzten Entscheidungspunkt zurück und teste eine andere Möglichkeit\\\pause
$\leadsto$ Problem: nicht akzeptierende Läufe können unendlich sein\pause
%
\item Breitensuche: berechne alle Läufe bis zu einer gewissen Tiefe, für immer größere Tiefen\\
$\leadsto$ Simulation eines Laufs wird bei Maximaltiefe abgebrochen
\end{itemize}

\end{frame}

\begin{frame}[t]\frametitle{Nichtdeterminismus $\neq$ mehr Ausdrucksstärke\phantom{g}}

\theobox{\emph{Satz:} Jede NTM ist äquivalent zu einer DTM.}\pause

\emph{Beweis:} Die Simulation verwendet eine 3-Band-TM (äquivalent zu einer normalen DTM wie bereits gezeigt):
\begin{enumerate}[\color{darkblue}{Band} 1:]
\item Eingabewort (wird nie verändert)
\item Arbeitsband der simulierten NTM für aktuellen Lauf
\item Beschreibung der Übergangsentscheidungen des aktuell simulierten Laufs
\end{enumerate}\pause
Für jeden Übergang gibt es nur endlich viele Optionen, sagen wir $\ell$.\medskip\pause%

Dann kann eine Folge von Entscheidungen als Sequenz von Zahlen in $\{0,\ldots, \ell-1\}$ beschrieben werden\\
$\leadsto$ Band 3 enthält solch ein Wort über $\{0,\ldots, \ell-1\}$\medskip\pause%

Der Inhalt von Band 3 kann als \redalert{Zahl zur Basis $\ell$} gelesen werden: Um systematisch alle Optionen
zu durchsuchen, kann diese Zahl in Schritten von $1$ erhöht werden.$^1$\medskip

{\footnotesize $^1$ Hierbei muss eine leicht modifizierte Form von "`Inkrementierung"' verwendet werden, welche die folgende Sequenz erzeugt:
\ghost{$0,1,\ldots,(\ell-1),00,01,\ldots,0(\ell-1),10,11,\ldots,(\ell-1)(\ell-1),000,001,\ldots$}

}

\end{frame}

\begin{frame}[t]\frametitle{Nichtdeterminismus $\neq$ mehr Ausdrucksstärke\phantom{g}}

\theobox{\emph{Satz:} Jede NTM ist äquivalent zu einer DTM.}

\emph{Beweis:} Arbeitsweise der Simulation:\pause
\begin{enumerate}[(1)]
\item Initialisiere Band 3 mit dem Inhalt $0$\pause
\item Kopiere die Eingabe von Band 1 nach Band 2\pause
\item Simuliere einen Lauf der NTM auf Band 2. In jedem Schritt wird von Band 3 eine Zahl gelesen
und der Übergang ausgeführt, der dieser Zahl entspricht.
\begin{itemize}
\item Falls ein Übergang mit der gelesenen Zahl nicht möglich ist, gehe zu (4)
\item Falls alle Zahlen auf Band 3 gelesen sind, gehe zu (4)
\end{itemize}\pause
\item Prüfe ob die simulierte NTM in einem Endzustand angehalten hat und akzeptiere in diesem Fall, andernfalls:
\item Inkrementiere die Zahl auf Band 3, lösche Band 2 und gehe zu Schritt (2)\qed
\end{enumerate}

\end{frame}

\begin{frame}[t]\frametitle{Komplexität und Terminierung}

\theobox{\emph{Satz:} Jede NTM ist äquivalent zu einer DTM.}

\emph{Komplexität:}
Wenn die NTM einen akzeptierenden Lauf der Länge $n$ hat, dann findet ihn die DTM nach
$O(\ell^n)$ Schritten.
\medskip

$\leadsto$ \redalert{Exponentielle Komplexität}

(Es ist bis heute unbekannt, ob es eine effizientere Simulation geben könnte -- scheinbar nicht, aber der Beweis steht aus)\pause\bigskip

\emph{Terminierung:}
Wenn die NTM ein Entscheider ist (auch bei Nichtakzeptanz garantiert hält), dann ist die
simulierende DTM \ghost{\ldots}\\\pause \redalert{nicht unbedingt ein Entscheider {\tiny(da die Simulation auch bei endlicher Nichtakzeptanz weiter fortgesetzt wird)}.} 
\medskip

Der Beweis kann allerdings so abgewandelt werden, dass diese Eigenschaft gilt, also:

\theobox{\emph{Satz:} Jede Sprache die von einer NTM entschieden wird, kann auch von einer DTM entschieden werden.}

\end{frame}

\begin{frame}\frametitle{TM, DFA und PDA}

\redalert{Mehrband-NTMs} und ihre Äquivalenz zu 1-Band-NTMs sind analog zum deterministischen Fall.
\medskip

Damit ist leicht zu sehen:
\begin{itemize}
\item Ein DFA kann als DTM aufgefasst werden, welche die Eingabe auf dem Band nur in einer Richtung
liest und niemals beschreibt.
\item Ein PDA kann als 2-Band-NTM aufgefasst werden, die das zweite Band als Kellerspeicher verwendet.
\end{itemize}

\end{frame}

\begin{frame}\frametitle{Church-Turing-These}

\anybox{purple}{\emph{Church-Turing-These:} Eine Funktion ist genau dann im intuitiven Sinne berechenbar, wenn es
eine Turingmaschine gibt, die für jede mögliche Eingabe den Wert der Funktion auf das Band schreibt und anschließend hält.
}

In der Tat sind eine große Menge von Ansätzen genau gleich stark:
\begin{itemize}
\item Turingmaschinen in vielen Varianten (deterministisch/nichtdeterministisch, Einband/Mehrband,
einseitig/zweiseitig unendlich, mit/ohne wahlfreiem Zugriff, \ghost{\ldots)}
\item $\lambda$-Kalkül nach Church
\item Gödel und Herbrands allgemeine rekursive Funktionen
\item alle bekannten Programmiersprachen\footnote{Sofern wir eventuelle technische Beschränkungen der maximalen verwendbaren Speichergröße ignorieren.}
\item Typ-0-Sprachen
\item Prädikatenlogik (erster Stufe)
\end{itemize}

\end{frame}

\begin{frame}\frametitle{Turing-Mächtigkeit}

\defbox{%
Ein Formalismus ist \redalert{Turing-mächtig}, wenn er das Ein-/Ausgabe-Verhalten jeder Turing-Maschine simulieren kann.}\bigskip

\emph{Vorteil:} Turing-Mächtigkeit garantiert ein Maximum an Ausdrucksstärke\\
$\leadsto$ gewünscht besonders bei Programmiersprachen
\bigskip

\emph{Nachteil:} Turing-Mächtigkeit bedeutet, dass viele Fragen in Bezug auf die berechnete Funktion unentscheidbar sind (z.B. Äquivalenz zweier Darstellungen) \\
$\leadsto$ zumeist unerwünscht, wenn nicht programmiert wird

\end{frame}

\begin{frame}\frametitle{Versehentlich Turing-mächtig (1)}

Immer wieder stellen sich bestimmte Technologien und formale Systeme unerwartet als
Turing-mächtig heraus.\pause
\vspace{3mm}

\anybox{purple}{
{\large \alert{C++ Templates}}
\bigskip

Ein Mechanismus zur generischen Programmierung in C++, bei dem zur Compilezeit (beliebig viele) Code-Templates instantiiert werden. Damit lassen sich TMs simulieren. Daher ist das Halteproblem für C++-Compiler unentscheidbar.
Sogar die Frage, ob eine gegebene Textdatei ein gültiges C++-Programm ist, ist unentscheidbar.
Praktisch wurde demonstriert, wie der Compiler Primzahlen berechnen und als Compilerfehler ausgeben kann.
}

\end{frame}

\begin{frame}\frametitle{Versehentlich Turing-mächtig (2)}

Immer wieder stellen sich bestimmte Technologien und formale Systeme unerwartet als
Turing-mächtig heraus.
\vspace{3mm}

\anybox{purple}{
{\large \alert{TypeScript Typsystem:}}
\bigskip

Rekursive definierte Typen in TypeScript ermöglichen es, beliebige Berechnungen allein im Typsystem zu implementieren.
Erstmals veröffentlicht von Henning Dieterichs, 2017 \href{https://github.com/Microsoft/TypeScript/issues/14833}{[Link]}.
In 2025 wurde eine erste vollständige Implementierung von DOOM in TypeScript Typen vorgestellt \href{https://www.youtube.com/watch?v=0mCsluv5FXA}{[Link]}, wobei Typdefinitionen im Umfang von insgesamt 177TB nötig waren.
}


\end{frame}

\begin{frame}\frametitle{Versehentlich Turing-mächtig (3)}

Immer wieder stellen sich bestimmte Technologien und formale Systeme unerwartet als
Turing-mächtig heraus.
\vspace{3mm}

\anybox{purple}{
{\large \alert{Java Generics:}}
\bigskip

Mechanismus zur generischen Programmierung in Java. Sollte die Turing-Vollständigkeit
von C++-Templates vermeiden. Offenbar ist das nicht gelungen. Erstmals publiziert Mai 2016.
}


\end{frame}

\begin{frame}\frametitle{Versehentlich Turing-mächtig (4)}

Immer wieder stellen sich bestimmte Technologien und formale Systeme unerwartet als
Turing-mächtig heraus.
\vspace{3mm}

\anybox{purple}{
{\large \alert{Sendmail:}}
\bigskip

SMTP-Server, welcher die automatische Umschreibung von Emails mit Regeln unterstützt.
Die Zeichenketten können in diesem Zusammenhang fast direkt als Speicherband verwendet werden (ähnliche Effekte gibt es bei anderen String-Umschreibungs-Systemen, wie Apache Rewrite Rules, wenn diese nicht in ihrer Rekursionstiefe beschränkt werden).
}

\end{frame}

\begin{frame}\frametitle{Versehentlich Turing-mächtig (5)}

Immer wieder stellen sich bestimmte Technologien und formale Systeme unerwartet als
Turing-mächtig heraus.
\vspace{3mm}

\anybox{purple}{
{\large \alert{X86 Memory Management Unit:}}
\bigskip

Hardwarekomponente einer verbreiteten Computerarchitektur.
Die Verarbeitung von Seitenfehlern (page faults) kann genutzt werden, um eine Turing-vollständige Berechnung
in Gang zu setzten, ohne die CPU zu verwenden. Demonstriert wurde eine Implementierung von Conway's Game of Life.
}

\end{frame}

\begin{frame}\frametitle{Versehentlich Turing-mächtig (6)}

Immer wieder stellen sich bestimmte Technologien und formale Systeme unerwartet als
Turing-mächtig heraus.
\vspace{3mm}

\anybox{purple}{
{\large \alert{SQL:}}
\bigskip

Verbreitete Anfragesprache für relationale Datenbanken. Mit Hilfe von rekursiven Hilfstabellen
(Common Table Expressions/\texttt{WITH RECURSIVE}) kann eine einzelne Abfrage Turingmaschinen simulieren.
}

\end{frame}

\begin{frame}\frametitle{Versehentlich Turing-mächtig (7)}

Immer wieder stellen sich bestimmte Technologien und formale Systeme unerwartet als
Turing-mächtig heraus.
\vspace{3mm}

\anybox{purple}{
{\large \alert{Magic: The Gathering:}}
\bigskip

Populäres Tauschkartenspiel. Es ist möglich, einen
Spielverlauf zu konstruieren, bei dem Spieler fast keine Entscheidungen treffen müssen und die komplexen 
Spielregeln automatisch zur Entwicklung einer TM-Simulation führen. Dabei wird ein Stapelspeicher als Reihe
von Zombies mit linear ansteigenden Lebenspunkten repräsentiert.\\
\href{https://arxiv.org/abs/1904.09828}{[Paper]} \href{https://www.youtube.com/watch?v=pdmODVYPDLA}{[Video]} 
}

\end{frame}

\begin{frame}\frametitle{Versehentlich Turing-mächtig (8)}

Immer wieder stellen sich bestimmte Technologien und formale Systeme unerwartet als
Turing-mächtig heraus.
\vspace{3mm}

\anybox{purple}{
{\large \alert{Microsoft Powerpoint:}}
\bigskip
Programm zum Erstellen von Präsentationen. Simulationen von Turing-Maschinen
auf beliebigem aber begrenztem Speicher können allein durch Animationen, Links
und AutoShapes (ohne VB Makros etc.) realisiert werden. Praktisch wurde lediglich demonstriert, wie man Palindrome gerader Länge erkennen kann. Veröffentlicht April 2017.\\
\href{https://youtu.be/uNjxe8ShM-8}{[Video]} \href{https://www.andrew.cmu.edu/user/twildenh/PowerPointTM/Paper.pdf}{[Paper]}
}

(Weitere Beispiele siehe \url{http://beza1e1.tuxen.de/articles/accidentally_turing_complete.html}.)

\end{frame}

\begin{frame}\frametitle{Zusammenfassung und Ausblick}

Die Theorie der Informatik untersucht Systeme im Hinblick auf ihre Fähigkeit zur Informationsverarbeitung (Berechnung)
\bigskip

Grundbegriffe: Turingmaschine (det./nichtdet.), Konfiguration, Lauf, Akzeptanz
\bigskip

Nichtdeterministische Turingmaschinen (NTMs) haben die gleiche Ausdrucksstärke wie deterministische
\bigskip

Church-Turing-These: "`Alle Computer sind gleich"'
\bigskip

\anybox{yellow}{
Was erwartet uns als nächstes?
\begin{itemize}
\item Probleme
\item Paradoxien
\item Phenomenal große Zahlen
\end{itemize}
}

\end{frame}

\begin{frame}[t]\frametitle{Bildrechte}

Folie \ref{frame_paris}: Fotografie von 1900, gemeinfrei\\
Folie \ref{frame_hilbert}: Fotografie von 1912, gemeinfrei\\
Folie \ref{frame_turing_child}: Fotografie von 1917, gemeinfrei\\

\end{frame}


\end{document}
